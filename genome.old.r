g$sam2gvcf <- function(inputfish = "", chrname = "", mem = 4, walltime = 72, recalibrate = TRUE,
		recalPlot = FALSE, Rversion = "3.1.2", GATKversion = "3.4.0", 
		genome = "gasAcu1pitx1new.fa", knownsites = "knownSnpsAllchrPitx1new.vcf", run = TRUE){
	# Takes .sam file all the way to gvcf file for a single fish.
	# Based on "sam2haplotypeCallerWithRecalibration.pbs" -- including arguments, for simplicity
	# RGPU (see below) is fixed as "Benlim-q15"
	# Recalibration is optional.
	# if recalPlot = TRUE, certain R libraries must be installed, see GATK help for AnalyzeCovariates.

	if(inputfish == "") stop("You need to provide inputfish")
	if(chrname != "") stop("Code not working for a single chromosome yet")
	if(genome != "gasAcu1pitx1new.fa") stop("Code currently works only with gasAcu1pitx1new.fa")
	if(knownsites != "knownSnpsAllchrPitx1new.vcf") stop("Code works only with knownSnpsAllchrPitx1new.vcf")

	# Attach date and time to name of pbs file to make unique
	hour <- gsub("[ :]", "-", Sys.time())
	pbsfile <- paste("sam2gvcf-", inputfish, chrname, "-", hour, ".pbs", sep = "")
	outfile <- file(pbsfile, "w")
	
	writeLines(			"#!/bin/bash", outfile)
	writeLines(			"#PBS -S /bin/bash", outfile)
	writeLines(paste(	"#PBS -l walltime=", walltime, ":00:00", sep=""), outfile)
	writeLines(paste(	"#PBS -l mem=", mem, "gb", sep = ""), outfile)

	writeLines(	"\n# pbs file to run sam2gvcf, based on 'sam2haplotypeCallerWithRecalibration.pbs'", outfile)
	writeLines(	  "# THIS FILE IS GENERATED BY R, DO NOT EDIT\n", outfile)
	
	writeLines("\necho \"Starting run at: \`date\`\"", outfile)

	writeLines('
	samfile="${inputfish}.sam"
	outfile="${inputfish}.out"
	RGID="BENLIM.${inputfish}"
	RGLB="${inputfish}.SB"
	RGSM="${inputfish}" 
	RGPL="ILLUMINA" 
	RGPU="Benlim-q15"
	fastafile="gasAcu1pitx1new.fa"
	faifile="gasAcu1pitx1new.fa.fai"
	dictfile="gasAcu1pitx1new.dict"
	intervals="${inputfish}.intervals"
	sortedbam="${inputfish}.sorted.bam"
	realignedbam="${inputfish}.realigned.bam"
	mkdupmetrics="${inputfish}.mkdup.metrics"
	mkdupbam="${inputfish}.mkdup.bam"
	mkdupbai="${inputfish}.mkdup.bai"
	reducedbam="${inputfish}.reduced.bam"
	vcffile="${inputfish}.vcf"
	recalbam="${inputfish}.recal.bam"
	recaltable="${inputfish}.recal.table"
	afterrecaltable="${inputfish}.after.recal.table"
	recalplots="${inputfish}.recal.pdf"
	
	module load samtools	
	', outfile)

	writeLines(paste('module load gatk', GATKversion, sep = "/"), outfile)
	writeLines(paste('module load R', Rversion, sep = "/"), outfile)

	writeLines('
	if [ ! -f "$dictfile" ]; then
	    java -Xmx2g -jar /global/software/picard-tools-1.89/CreateSequenceDictionary.jar R=$fastafile O=$dictfile
	fi
	
	if [ ! -f "$faifile" ]; then
	    samtools faidx $fastafile
	fi
	
	# 1. SortSam
	java -Xmx2g -jar /global/software/picard-tools-1.89/SortSam.jar I=$samfile O=$sortedbam \\
		SORT_ORDER=coordinate CREATE_INDEX=TRUE VALIDATION_STRINGENCY=LENIENT
	
	# 2. MarkDuplicates
	java -jar /global/software/picard-tools-1.89/MarkDuplicates.jar \\
		I=$sortedbam O=$mkdupbam M=$mkdupmetrics \\
		VALIDATION_STRINGENCY=LENIENT REMOVE_DUPLICATES=FALSE ASSUME_SORTED=TRUE
	
	# 3. AddOrReplaceReadGroups
	java -Xmx2g -jar /global/software/picard-tools-1.89/AddOrReplaceReadGroups.jar \\
		RGID=$RGID RGLB=$RGLB RGSM=$RGSM RGPL=$RGPL RGPU=$RGPU I=$mkdupbam O=$sortedbam \\
		SORT_ORDER=coordinate CREATE_INDEX=TRUE VALIDATION_STRINGENCY=LENIENT
	
	# 4. RealignerTargetCreator
	gatk.sh -Xmx4g -T RealignerTargetCreator -R $fastafile -I $sortedbam -o $intervals \\
		--allow_potentially_misencoded_quality_scores
	
	# 5. IndelRealigner:
	gatk.sh -Xmx4g -T IndelRealigner -R $fastafile -I $sortedbam -targetIntervals $intervals \\
		-o $realignedbam -LOD 0.4 --allow_potentially_misencoded_quality_scores
	', outfile)
	
	if(recalibrate){
		writeLines('
		# 6. BaseRecalibrator
		gatk.sh -Xmx4g -T BaseRecalibrator -R $fastafile -I $realignedbam \\
			-knownSites knownSnpsAllchrPitx1new.vcf -o $recaltable
		gatk.sh -Xmx4g -T PrintReads -R $fastafile -I $realignedbam -BQSR $recaltable -o $recalbam 
		', outfile)
		
		if(recalPlot){	
			writeLines('
			gatk.sh -Xmx4g -T BaseRecalibrator -R $fastafile -I $realignedbam \\
				-knownSites knownSnpsAllchrPitx1new.vcf -BQSR $recaltable -o $afterrecaltable
			gatk.sh -Xmx4g -T AnalyzeCovariates -R $fastafile -before $recaltable \\
				-after $afterrecaltable -plots $recalplots
			', outfile)
			}
		
		writeLines('
		# 7. HaplotypeCaller
		gatk.sh -Xmx4g -T HaplotypeCaller -R $fastafile -I $recalbam \\
		     --emitRefConfidence GVCF --variant_index_type LINEAR --variant_index_parameter 128000 \\
		      -o $vcffile --allow_potentially_misencoded_quality_scores
		', outfile)
	
		} else{
		writeLines('
		# 7. HaplotypeCaller
		gatk.sh -Xmx4g -T HaplotypeCaller -R $fastafile -I $realignedbam \\
		     --emitRefConfidence GVCF --variant_index_type LINEAR --variant_index_parameter 128000 \\
		      -o $vcffile --allow_potentially_misencoded_quality_scores
		', outfile)
		}

	writeLines('\nexit 0', outfile)

	writeLines('\necho \"Job finished with exit code $? at: \`date\`\"', outfile)
	
	close(outfile)
	
	# Use as "qsub -v inputfish=PRIL17 sam2haplotypeCallerWithRecalibration.pbs
	if(run){
		qsub <- paste("qsub -v inputfish=", inputfish, sep = "")
		system(paste(qsub, pbsfile))
		}
	}

g$makePbsRunRscript <- function(Rscript = "", Rversion = "3.1.2", mem = 2, walltime = 24, run = TRUE){
	# Creates a *.pbs file to run the full Rscript command "Rscript"
	# The Rscript command executes a particular *.R file and provides any needed arguments
	# This version also downloads the .R file from github so that the latest version is available
	# This version does not include pbsfile as an argument, it will make from the .R root
	# This version automatically submits the pbs file to the queue
	# Example: (note that all the arguments to .R script are included in a single quotation
	# 	g$makePbsRunRscript(Rscript = "countInvariantsByGroup.R BenlimPax22pacMar7 chrXXI 1 paxl paxb marine-pac")
	
	if(Rscript == "") stop("You need to provide an Rscript command")
		
	# Remove and repaste initial "Rscript" command if present in case it is missing from the Rscript text submitted
	# Also grab the name of the .R file argument, store in dotRfile
	Rscript <- sub("^[ ]*Rscript[ ]*|[ ]*", "", Rscript, ignore.case = TRUE)
	dotRfile <- strsplit(Rscript, split = " ")[[1]][1]
	dotRfile <- gsub("[.]R", "", dotRfile, ignore.case = TRUE)
	Rscript <- paste("Rscript", Rscript)
	
	# Attach date and time to name of file to make unique
	# pbsfile <- gsub(".pbs$", "", pbsfile)
	hour <- gsub("[ :]","-",Sys.time())
	pbsfile <- paste(dotRfile, "-", hour, ".pbs", sep = "")
	
	outfile <- file(pbsfile, "w")
	writeLines("#!/bin/bash", outfile)
	writeLines("#PBS -S /bin/bash", outfile)
	writeLines(paste("#PBS -l walltime=", walltime, ":00:00", sep=""), outfile)
	writeLines(paste("#PBS -l mem=", mem, "gb", sep = ""), outfile)
	#writeLines("#PBS -l epilogue=epilogue.script", outfile)

	#writeLines(paste("#PBS -N", jobname), outfile)
	writeLines("\n# Generic torque file to run Rscript", outfile)
	writeLines("# THIS FILE IS GENERATED BY R, DO NOT EDIT\n", outfile)
	writeLines("# Run as \"qsub pbsfile.pbs\"\n", outfile)
	
	writeLines("\necho \"Starting run at: \`date\`\"", outfile)

	# writeLines(paste("curl -o " , dotRfile, ".R", 
		# " https://raw.githubusercontent.com/dschluter/RScripts/master/", dotRfile, ".R", sep = ""), outfile)

	writeLines(paste("module load R/", Rversion, sep = ""), outfile)
	writeLines(Rscript, outfile)

	writeLines("\necho \"Job finished with exit code $? at: \`date\`\"", outfile)
	
	close(outfile)
	if(run) system(paste("qsub", pbsfile))
	}
